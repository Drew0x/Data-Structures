An outline of a linked implementation of the ADT Stack

public final class LinkedStack<T> implemenets StackInterface<T>
{
private Node topNode;

public LinkedStack()
{
topNode = null;
}
private class Node
{
private T data;
private Node next;
<Constructors and the methods getData, setData, getNextNode and setNextNode are here.>
}
}

Adding to the top of the stack::
public void push(T newEntry) {
  Node newNode = new Node(newEntry, topNode);
  topNode = newNode;
}

Retrieving the top of the stack::
public T peek()
{
  if(isEmpty())
    throw new EmptyStackException();
  else
    return topNode.getData();
}

Removing the top::
public T pop()
{
T top = peek();
assert topNode != null;
topNode = topNode.getNextNode();
return top;
}

Pop rewritten without using peek::
public T pop()
{
  if (topNode != null)
  T top = topNode.getData();
  topNode = topNode.getNextNode();
  return top;
} else
throw new EmptyStackException();
}

An outline of an array-based implementation of the ADT stack

public final class ArrayStack<T> implements StackInterface<T>
{
  private T[] stack;
  private int topIndex;
  private static final int DEFAULT_CAPACITY = 50;
  private static final int MAX_CAPACITY = 10000;

public ArrayStack() {
  this(DEFAULT_CAPACITY);
}
public ArrayStack(int initialCapacity) {
  checkCapacity(initialCapacity);

  @SuppressWarnings("unchecked")
  T[] tempStack = (T[])new Object[initialCapacity];
  stack = tempStack;
  topIndex = -1;
  initialized = true;
}


Adding to the top: The push method checks whether the array has room for a new entry by calling the private method ensureCapacity. if then places the new entry immediately after the last occupied lcoation in the array:
public void push(T newEntry)
{
  checkInitialization();
  ensureCapacity();
  stack[topIndex + 1] = newEntry();
  topIndex++;
}
private void ensureCapacity()
{
  if(topIndex == stack.length -1)
{
int newLength = 2 * stack.length;
checkCapcity(newLength);
stack = Arrays.copOf(stack, newLength);
}
}

Retrieving the top: The operation peek either returns the array entry at topIndex or throws an exception if the stack is empty:
public T peek() {
  checkInitialization();
  if(isEmpty())
    throws new EmptyStackException();
  else
    return stack[topIndex];
}

Removing the top::: the pop operation like peek retrieves the top entry in the stack but then removes it. To remove the stacks top entry we could simply decrement topIndex.
public T pop() {
  checkInitializaiton();
if(isEmpty())
  throw new EmptyStackException();
else {
  T top = stack[topIndex];
  stack[topIndex] = null;
  topIndex--;
  return top;
}
}

The methods isEmpty and clear::
public boolean isEmpty() {
  return topIndex < 0;
}

Java Class Library: The Class Vector:::
The java class livrary contains a class vector whose instances called vectors behave like a resizable array. Here are some constructors and methods of Vector that we will use to implement the ADT stack:
public Vector()
  creates an empty vector or array like container with an initial capacity of 10. When the vector needs to increase its capacity the capacity doubles.
public Vector(int initialCapacity)
  Creates an empty vector with the specified initial capacity. When the vector needs to increase its capcity the capacity doubles.
public boolean add(T newEntry)
  Adds a new entry to the end of this vector.
public T remove(int index)
  Removes and returns the entry at the given index in this vector
public void clear()
  Removes all entries from this vector
public T lastElement()
  returns true if this vector is empty
public int size()
  returns the number of entries currently in thsi vector.





An outline of a vector based ipmlementation of the Adt stack::::
public final class VectorStack<T> implements StackInterface<T>
{  
  prviate Vector<T> Stack;
  private boolean initialized = false;
  private static final int DEFAULT_CAPACITY = 50;
  private static final int MAX_CAPACITY = 10000;

  public VectorStack()
{
  this(DEFAULT_CAPCITY);
}

  public VectorStack(int initialCapcity)
{
  checkCapcity(initialCapcity);
  stack = new Vector<>(initialCapacity);
  initialized = true;
}

ADDING TO THE TOP:::
public void push(T newEntry) {
  checkInitialization();
  stack.add(newEntry);
}

RETRIVEING THE TOP::
public T peek() {
  checkInitialization();
  if(isEmpty()) 
    throw new EmptyStackException();
  else
    return stack.lastElement();
}


Removing the TOP:::

public T top() {
checkInitialzation();
  if(isEmpty())
    throw new EmptyStackException();
  else
    return stack.remove(stack.size() -1);
}

Rest of the class:::
public boolean isEmpty() {
  return stack.isEmpty();
}
public void clear()
{
  stack.clear();
}
















