Nodes:
class Node {
private T data;
private Node next;
<Constructors>
...
<Accessors and mutator methods: getData, setData, getNextNode, setNextNode >
...
} // end node




Private Innet class NODE

private class Node {
private T data;
private Node next;

private Node(T dataPortion) {
this(dataPortion, null);
} //end constructor

private Node(T dataPortion, Node nextNode) {
data = dataPortion;
next = nextNode;
} //end constructor
} //end Node


NOTE: TERMINOLOGY::::
nested class is defined entirely within another class definition. Nested classes can be static, although we will not encounter any in this book. An inner class is a nested class that is not static. An outer class or enclosing class, contains a nested class.
A top-level class is one that is not nested.

An Outline of the class LinkedBag:
/** A class of bags whose entries are stored in a chain of linked nodes.
The bag is never full.
@author Frank M. Carrano
*/
public final class LinkedBag<T> implements BagInterface<T> {
private Node firstNode; //Reference to first Node
private int numberOfEntries;

public LinkedBag() {
firstNode = null;
numberOfEntries = 0;
} //end default constructor

<Implementations of the public methods decleared in BagInterface go here.>

private class Node //Private inner class
{
<See Listing 3-1.>
} //end Node
} //end LinkedBag



First node reference:
Node newNode = new Node(newEntry);
newNode.next = firstNode;
firstNode = newNode;


Add method:
/** Adds a new entry to this bag.
@param newEntry The object to be added as a new entry.
@return True. */
public boolean add(T newEntry) //OutOfMemoryError possible
{
//Add to beginning of chain:
Node newNode = new Node(newEntry); //Make new node reference rest of chain
newNode.next = firstNode; //(firstNode is null if chain is empty)
firstNode = newNode;
numberOfEntries++;
} //end add

method ToArray:::
/** Retrieves all entries that are in this bag.
@return A newly allocated array of all the entries in the bag. */
public T[] toArray() {
// The cast is safe because the new array contains null entries
@SuppressWarnings("Unchecked")
T[] result = (T[])new Object[numberOfEntries]; //Unchecked cast
int index = 0;
Node currentNode = firstNode;
while((index < numberOfEntries) && (currentNode != null)) {
result[index] = currentNode.data;
index++;
currentNode = currentNode.next;
} //end while
return result;
} //end toArray

TIP:: If ref is a reference to a node in a chain, be sure that ref is not null before you use it to access ref.data or ref.next. Otherwise, if ref is null, a NullPointerException will occur.



A sample program that tests some methods in the class LinkedBag:
/** A test of the methods add, toArray, isEmpty, and getCurrentSize,
as defined in the first draft of the class LinkedBag.
@author Frank M. Carrano
*/
public class LinkedBagDemo1 {
public static void main(String[] args) {
System.out.println("Creting an empty bag.");
BagInterface<String> aBag = new LinkedBag<>();
testIsEmpty(aBag, true);
displayBag(aBag);

String[] contentsOfBag = {"A", "D", "B", "A", "C","A","D"};
testAdd(aBag, contentsOfBag);
testIsEmpty(aBag, false);
} //end main

//Tests the method isEmpty.
//PreCondition: If the bag is empty, the parameter empty should be true;
// otherwise, it should be false.
private static void testIsEmpty(BagInterface<String> bag, boolean empty)
{
System.out.println("\nTesting isEmpty with ");
if (empty)
  System.out.println("an empty bag: ");
else
  System.out.println("a bag that is not empty:");
System.out.println("isEmpty finds the bag ");
if(empty && bag.isEmpty())
  System.out.println("empty: OK.");
else if(empty)
  System.out.println("not empty, but it is: ERROR.");
else if(!empty && bag.isEmpty())
  System.out.println("empty, but it is not empty: ERROR.");
else
  System.out.println("not empty: OK.");
} //end testIsEmpty
<The static methods testAdd and displayBag from Listing 2-2 are here >
} // end LinkedBagDemo1



Method getFrequency:::
/** Counts the number of times a given entry appears in this bag.
@param anEntry The entry to be counted.
@return The number of times anEntry appears in the bag. */
public int getFrequencyOf(T anEntry)
{
int frequency = 0;
int loopCounter = 0;
Node currentNode = firstNode;
while ((loopCounter < numberOfEntries) && (currentNode != null)) 
{
  if (anEntry.equals(currentNode.data))
    frequency++;
  loopCounter++;
  currentNode = currentNode.next;
} // end while
return frequency;
} //end getFrequencyOf


Method Contains:::
public boolean contains(T anEntry) {
boolean found = false;
Node currentNode = firstNode;

while(!found && (currentNode != null))
{
  if (anEntry.equals(currentNode.data))
    found = true;
  else
    currentNode = currentNode.next;
} //end while
return found;
} // end contains



Remove Method:
public T remove() {
T result = null;
if (firstNode != null) {
result = firstNode.data;
firstNode = firstNode.next; //Remove first node from chain
numberOfEntires--;
} //end if 
return result;
} // end remove



Remove method::
public boolean remove(T anEntry) {
boolean result = false;
Node nodeN = getReferenceTo(anEntry);
if(nodeN != null) {
nodeN.data = firstNode.data; //Replace located entry with entry
  //in first node
firstNode = firstNode.next; //Remove first node
numberOfEntries--;
result = true;
} //end if
return result;
} // end remove


Clear Method:
public void clear() {
firstNode = null;
} //end clear

NOTE::After the method remove removes a node from a chain you have no way to reference the removed node, so you cannot use it. Moreover as Segment C.20 in Appendix C notes, the runtime environment automaticlaly deallocates and recycles the memory associated with the nodes. No explicity instruction from the programmer is necessary or in fact possible to cause deallocation to occur. 


THE innner class Node with set and get methods::::
private class Node {

private T data; //Entry in bag
private Node next; //Link to next node

private Node(T dataPortion) {
this(dataPortion, null);
} // end constructor

private Node(T dataPortion, Node nextNode) {
data = dataPortion;
next = nextNode;
} //end constructors

private T getData() {
return data;
} //end getData

private void setData(T newData) {
data = newData;
} //end setData

private Node getNextNode() {
return next;
} //end getNextNode

private void setNextNode(Node nextNode) {
next = nextNode;
} // end setNextNode
} // end Node




THE CLASS NODE WITH PACKAGE ACCESS:::
package BagPackage;
class Node<T>
{
  private T  data;
  private Node<T> next;

Node(T dataPortion, null); //The constructor's name is Node, not Node<T>
{
this(dataPortion, null);
} // end Constructor

Node(T dataPortion, Node<T> nextNode) {
data = dataPortion;
next = nextNode;
} // end Constructor

T getData()
{
return data:
} // end getData

void setData(T newData) 
{
 data = newData;
} // end setData

Node<T> getNextNode()
{
return next;
} // end getNextNode

void setNextNode(Node<T> nextNode)
{
next = nextNode;
} // end setNextNode
} //end Node






CLASS LINKEDBAG WHEN NODE IS IN THE SAME PACKAGE:::
package BagPackage;
public class LInkedBag<T> implements BagInterface<T>
{
private node<T> firstNode;
....

public boolean add(T newEntry)
{
Node<T> newNode = new Node<T>(newEntry);
newNode.setNextNode(firstNode);
firstNode = newNode;
numberOfEntries++;

return true;
} // end add
...
} // endLinkedBag




TIP::: If ref is a reference to a node in a chain, be sure that ref is not null before you use it to access ref .data or ref .next










