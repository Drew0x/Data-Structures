Queue is first in first out
Stack is last in first out

Abstract Data Type Queue:
A collection of objects in chronological order and having the same data type
enqueue(newEntry)
dequeue()
getFront()
isEmpty()
clear()

Interface for ADT Queue
public interface QueueInterface<T>
{
  public void enqueue(T newEntry);

  public T dequeue();

  public T getFront();

  public boolean isEmpty();

  public void clear();
} //end queue

QueueInterface<String> myQueue = new LinkedQueue<>();
myQueue.enqueue("Jim");
myQueue.enqueue("Jess");
myQueue.enqueue("Jill");
myQueue.enqueue("Jane");
myQueue.enqueue("Joe");

String front = myQueue.getFront();

front = myQueue.dequeue();

myQueue.enqueue("Jerry");

front = myQueue.getFront();

front = myQueue.dequeue();


Programming Tip:: Methods such as getFront and dequeue must behave reasonably where the queue is empty. Here, we specify that they throw an exception. Just as we discussed in Chapter 5 in the context of the ADT stack, other possibilities include returning null or giving these methods the precondition that the queue is not empty.


The class waitLine
/** Simulates a waiting line. */
public class WaitLine {
  private QueueInterface<Customer> line;
  private int numbnerOfArrivals;
  private int numberServed;
  private int totalTimeWaited;

public WaitLine()
{
  line = new LinkedQueue<>();
  reset();
} // end default constructor

/** Simulates a waiting line with one serving agent. 
    @param duration The number of simulated minutes.
    @param arrivalProbability. A real number between 0 and 1, and the probability that a customer arrives at a given time.
    @param maxTransactionTime. The longest transaction time for a customer. */
public void simulate(int duration, double arrivalProbability, int maxTransactionTime) {
  int transactionTimeLeft = 0;
  for(int clock = 0; clock < duration; clock++)
  {
    if(Math.random() < arrivalProbabilty)
{
    numberOfArrivals++;
    int transactionTime = (int)(Math.random() * maxTransactionTime + 1);
    Customer nextArrival = new Customer(clock, transactionTime, numberOfArrivals);
  line.enqueue(nextArrival);
  System.out.println("Customer " + numberOfArrivals + " enters line at time " + clock + ". Transaction time is " + transactionTime);
} // end if

  if(transactionTimeLeft > 0)
  transactionTimeLeft--;
  else if (!line.isEmpty())
  {
    Customer nextCustomer = line.dequeue();
    transactionTimeLeft = nextCustomer.getTransactionTime() -1;
    int timeWaited = clock - nextCustomer.getArrivalTime();
    totalTimeWaited = totalTimeWaited + timeWaited;
    numberServed++;
    System.out.println("Customer " + nextCustomer.getCustomerNumber() + " begins service at time " + clock + ". Time waited is " + timeWaited);

    } //end if
    } // end for
    } // end simulate
/** Displays summary results of the simulation */
public void displayResults()
{
  System.out.println();
  System.out.println("Number served = " + numberServed);
  System.out.println("Total time waited = " + totalTimeWaited);
  double averageTimeWaited = ((double)totalTimeWaited) / numberServed;
  System.out.println("Average time waited = " + averageTimeWaited);
  int leftInLine = numberOfArrivals - numberServed;
  System.out.println("Number left in line = " + leftInLine);
} // end display Results

/** Initializes the simulation */
public final void reset()
{
  line.clear();
  numberOfArrivals = 0;
  numberServed = 0;
  totalTimeWaited = 0;
} //end reset
} //end waitLine



StockLedger myStocks = new StockLedger();
myStocks.buy(20, 45);
myStocks.buy(20, 75);
double capGain = myStocks.sell(30, 65);


The class StockLedger
/** A class that recors the purchase and sale of stocks and provides captial gains or less. */
public class StockLedger {
  private QueueInterface<Stock Purchase> ledger;

public StockLedger() {
  ledger = new LinkedQueue<>();
} // end default constructor

/** Records a stock purchase in this ledger.
    @param sharesBought. The number of shares purchased.
    @param pricePerShare. The price per share. */
public void buy (int sharesBought, double pricePerShare)
{
  while(sharesBought > 0)
{
  StockPurchase purhcase = new StockPurchase(pricePerShare);
  ledger.enqueue(purchase);
  sharesBought--;
}//end while
} //end buy

/** Removes from this ledger any shares that were sold and computes the capital gain or loss.
  @param sharesSold  The number of shares sold.
  @param pricePerShare    The price per share.
  @return The capital gain(loss) */
public double sell(int sharesSold, double pricePerShare)
{
  double saleAmount = sharesSold * pricePerShare;
  double totalCost = 0;
while(sharesSold > 0)
{
  StockPurhcase share = ledger.dequeue();
  double shareCost = share.getCostPerShare();
  totalCost = totalCost + shareCost;
  sharesSold--;
} // end while
return saleAmount -totalCost;
} //end sell
}// end StockLedger


NOTE:: A class that has set methods is a class of mutable objects. A class without set methods is a class of immutable objects. Java interlude 6 talks about such classes in more detail.

public boolean add(T newEntry)
adds a new entry to the back of this queue returning true if successful and throwing an exception if not.

public boolean offer(T newEntry)
adds a new entry to the back of this queue, returning true or false according to the success of the operation.

public T remove()
Retrieves and removes the entry at the front of this queue, but throws NoSuchElementException if the queue is empty prior to the operation

public T poll()
Retrieves and removes the entry at the front of this queue, but returns null if the queue is empty prior to the operation.

public T element()
Retrieves the entry at the front of this queue, but throws NOSuchElementException if the queue is empty. Our method getFront throws an EmptyQueueException instead of a NoSuchElementException

public T peek()
Retrieves the entry at the front of this queue, but returns null if the queue is empty.

public boolean isEmpty()
Detects whether this queue is empty

public void clear()
Removes all entries from this queue

public int size()
Gets the numner of elements currently in this queue.

NOTE:: Although the ADT deque is called a double ended queue it actually behaves like a double ended stack. You can push pop or get items at either of its ends



An interface for the ADT deque

/** 
An interface for the ADR deque.
@author Fran M. Carrano */
public interface DequeInterface<T>
{
/** Adds a new entry to the front/back of this dequeue
@param newEntry An object to be added */
public void addToFront(T newEntry);
public void addToBack(T newEntry);

/** Removes and returns the front/back entry of this deque.
  @return The object at the front/back of the deque.
  @throws  EmptyQueueException if the deque is empty before the operation. */
public T removeFront();
public T removeBack();

/** Retrives the front/back entry of this deque.
  @return The object at the front/back of the deque.
  @throws EmptyQueueException if the deque is empty. */
public T getFront();
public T getBack();

/** Detects whether this deque is empty.
    @return True if the deque is empty, or false otherwise. */
public boolean isEmpty();
/*removes all entries from this deque. */
public void clear();
} //end DequeInterface



The interface Deque:
public void addFirst(T newEntry);
Adds a new entry to the front of this deque, but throws one of several exceptions if it cannot

public boolean offerFirst(T newEntry);
Adds a new entry to the front of this deque

public void addLast(T newEntry);
Adds a new entry to the back of this deque

public boolean offerLast(T newEntry);
Adds a new entry to the back of this deque

public T removeFirst();
Retrieves and removes the entry at the front of this deque

public T pollFirst();
Retrieves and removes the entry at the front of this deque but returns null if the deque is empty prior to operation

public T removeLast();
Retrieves and removes the entry at the back of this deque but throws NoSuchElementException if the deque is empty prior to the operation

public T pollLast();
Retrieves and removes the entry at the back of this deque

public T getFirst();
Retrieves the entry at the front of this deque.

public T peekFirst();
Retrieves the entry at the front of this deque

public T getLast();
Retrieves the entry at the back of this deque

public T peekLast();
Retrieves the entry at the back of this deque 

public boolean isEmpty();
Detects whether this deque is empty

public void clear();
removes all entries from this deque

public int size()
Gets the number of entries currently in this deque.


The interface Deque extends the interface Queue so it also has the methods add offer remove poll element and peek that were described earlier. And additional methods such as:
public void push(T newEntry)
public T pop()



An interface for the ADT priority Queue:::
public interface PriorityQueueInterface<T extends Comparable<? super T>>
{
/** Adds a new entry to this priority queue
@param newEntry An object to be added. */
public void add(T entry);

/** Removes and returns the entry having the highest priority.
  @return Either the object having the highest priority or it the priority queue is empty before the operation null. */
public T remove();

/** Retrieves the entry having the highest priority.
  @return Either the object having the highest priority or if the priority queue is empty null 8/
public T peek();

/** Detects whether this priority queue is empty
  @return True if the priority queue is empty or false otherwise */
public boolean isEmpty();

/** Gets the size of this priority queue.
@return the number of entries currently in the priority queue */
public int getSize();

/** Remvoes all entries from this priority queue. */
public void clear();
} //end PriorityQueueInterface


The class assignmentLog
import java.sql.Date;
public class AssignmentLog
{
  private PriorityQueueInterface<Assignments> log;

  public AssignmentLog()
  {
    log = new PriorityQueue<>();
} // end constructor

public void addProject(Assignment newAssignment)
{
  log.add(newAssignment);
} //end addProject

public void addProject(String courseCode, String task, Date dueDate)
{
    Assignment newAssignment = new Assignment(courseCode, task, dueDate);
    addProject(newAssignment);
}// end addProject

public Assignment getNextProject()
{ 
    return log.peek();
} // end getNextProject

public Assignmetn removeNextProject()
{
  return log.remove();
} //end removeNextProject 
} //end AssignmentLog


The Class PriorityQueue
public PriorityQueue()
Creates an empty priority queue whose initial capcity is 11 entries

public PriorityQueue(int initialCapacity)
Creates an empty priority queue having a given initial capacity

public boolean add(T newEntry)
Adds a new entry to this priority queue returning true if successful and throwing an exception if not

public boolean offer(T newEntry)
Adds a new entry to this priority queue returning true or false according to the success of the operation

public T remove()
Retrieves and removes the entry at the front of this priority queue but throws NoSuchElementException if the priority queue is empty prior to the operaiton

public T poll()
Retrieves and removes the entry at the front of this priority queue but returns null if the priority queue is empty prior to the operation

public T element()
Retrieves the entry at the front of this priority queue but throws NoSuchElementException if the priority queue is empty

public T peek()
retrieves the entry at the front of this priority queue but returns null if the priority queue is empty

public boolean isEmpty()
Detects whether this priority queue is empty

public void clear()
Removes all entries from this priority queue

public int size()
Gets the number of elements currently in this priority queue.


An outline of a linked implementation of the ADT queue
/**
  A class that implements a queue of objects by using a chain of linked nodes.
  @authro Frank M. Carrano
*/
public final class LinkedQueue<T> implements QueueInterface<T>
{
  private Node firstNode; //References node at front of queue
  private Node lastNode; //References node at back of queue

public LinkedQueue()
{
    firstNode = null;
    lastNode = null;
} //end default constructor

<Implementations of the queue operations go here.>
private class Node
{
  private T data; //Entry in queue
  private Node next; //Link to the nextNode
<Constructors and the methods getData, setData, getNextNode, and setNextNode are here>
} // end Node
} //end LinkedQueue


Definition of Enqueue
public void enqueue(T newEntry)
{
  Node newNode = new Node(newEntry, null);
  if(isEmpty())
    firstNode = newNode;
  else
    lastNode.setNextNode(newNode);
  lastNode = newNode;
} //end enqueue


Retrieving the FrontEntry
public T getFront()
{
  if(isEmpty())
    throw new EmptyQueueException();
  else
    return firstNode.getData();
} //end getFront

Removing the FrontEntry
public T dequeue()
{
    T front = getFront();
    assert firstNode != null;
    firstNode.setData(null);
    firstNode = firstNode.getNextNode();
    if(firstNode == null)
      lastNode = null;
  return front;
} // end dequeue


Empty 
public boolean isEmpty()
{
    return (firstNode == null) && (lastNode == null);
} // end isEmpty

Clear
public void clear()
{
  firstNode = null;
  lastNode = null;
} //end clear



NOTE::: With a circular array, frontIndex equals backIndex + 1 both when the queue is empty and when it is full

An outline of an array-based implementation of the ADT queue
/** 
  A class that implements a queue of objects by using an array.
  @author Frank M. Carrano
  */
public final class ArrayQueue<T> implements QueueInterface<T>
{
  private T[] queue; //Circular array of queue entries and one unused location
  private int frontIndex;
  private int backIndex;
  private boolean initialized = false;
  pivate static final int DEFAULT_CAPACITY = 50;
  private static final int MAX_CAPACITY = 10000;

public ArrayQueue()
{
  this(DEFAULT_CAPACITY)
} // end default constructor

public ArrayQueue(int initialCapacity)
{
  checkCapacity(initialCapacity);

//The cast is safe because the new array contains null entries
@SuppressWarnings("Unchecked")
T[] tempQueue = (T[]) new Object[initialCapacity +1];
queue = tempQueue;
frontIndex = 0;
backIndex = initialCapacity;
initialized = true;
} // end constructor
<Implementations of the queue operaitons go here.>
} // end ArrayQueue




Adding to the Back::
public void enqueue(T newEntry)
{
  checkInitialization();
  ensureCapacity();
  backIndex = (backIndex + 1) % queue.length;
  queue[backIndex] = newEntry;
} // end enqueue



Retrieving the front entry::
public T getFront()
{
  checkInitialization();
  if(isEmpty())
    throw new EmptyQueueException();
  else
    return queue[frontIndex];
} // end getFront
This operation is 0(1)


public T dequeue()
{
    checkInitialization();
    if(isEmpty())
      throw new EmptyQueueException();
    else
    {
      T front = queue[frontIndex];
      queue[frontIndex] = null;
      frontIndex = (frontIndex + 1) % queue.length;
      return front;
} // end if
} // end dequeue
This is an 0(1) operation

Ensure Cacity Method
//Doubles the size of the array queue if it is full.
// Precondition: checkInitialization has been called
private void ensureCapacity()
{
  if(frontIndex == ((backIndex + 2) % queue.length)) //If array is full it will double the size
  {
    T[] oldQueue = queue;
    int oldSize = oldQueue.length;
    int newSize = 2 * oldSize;
    checkCapacity(newSize - 1);
    // The cast is safe because the new array contains null entries
    @SuppressWarnings("Unchecked")
    T[] tempQueue = (T[]) new Object[newSize];
    queue = tempQueue;
    for(int index = 0; index < oldSize -1; index ++) {
      queue[index] = oldQueue[frontIndex];
      frontIndex = (frontIndex + 1) % oldSize;
      } //end for
      frontIndex = 0;
      backIndex = oldSize -2;
} //end if
} // end ensureCapacity

Clearing the class
public boolean isEmpty()
{
  return frontIndex == ((backIndex + 1) % queue.length);
} // end isEmpty







































